#!/usr/bin/env python

import sysman.client,sysman.confhandler,sysman.commandoptions
import sysman.commandoptions
from sysman.colours import *

import socket,re,cPickle
from subprocess import call

NOTSAVED = 0
SAVED = 1
NOFILE = 2

commopt = sysman.commandoptions.Commandoptions()
defaultport = commopt.options.port
conffile = commopt.options.conffile
sysscfg = sysman.confhandler.Configuration(conffile)
statusmsg = ''
#global activesys
if sysscfg.is_config_available(conffile):
    saved = SAVED
else:
    saved = NOFILE

# TEST PORPOSE

#serverport = 61874
#servername = socket.gethostname()
#if servername == 'Giove':
#    systems = sysman.confhandler.Configuration('/home/fabrizio/APPO/bck/sysmand.xml.save')
#elif servername == 'D03':
#    systems = sysman.confhandler.Configuration('/home/frosa/APPO/bck/sysmand.xml.save')
#systems.load_conf()
#ucraina = systems.get_system('Ucraina')

#print 'Starting connection to server ' + servername + ' at port ' + str(serverport)
# TEST PORPOSE END

#print 'Type \'help\' for command list. Type \'quit\' to end session'

def query(servername,serverport,comm):
#        match = re.match('^(.+):(.+)$',comm)
#        if not match:
#            comm = comm + ':nop'
    connection = sysman.client.Client(servername,serverport)
    info = re.sub('[\n\r]','',connection.query(comm))
    connection.socket().close()
    return info

def io():
    global statusmsg
    if not saved == NOFILE:
        statusmsg = 'Config file available: ' + conffile
    else:
        statusmsg = 'Config file not available'
    commandlist = []
    new_comm('open system',open_sys,commandlist)
    new_comm('create system',create_sys,commandlist)
    new_comm('delete system',delete_sys,commandlist)
    new_comm('save configuration',save_conf,commandlist)
    while True:
        comm = menu('Main Menu',commandlist,clean=1)
        if comm == 'q':
            break
    print 'Bye!'

def head(title):
    global statusmsg
    head =  '\n\n\n:::: '+ red_bold('SysMan System Management') + ' ::::\n\n'
    head = head + ' :: ' + yellow_bold(statusmsg) + ' ::\n\n'
    head = head + sub_head() +'\n'
    head = head + ' ::  ' + green_bold_reverse(title) + '  ::\n\n'
    return head
    
def sub_head():
    global activesys,saved,conffile
    try:
        sysname = bold(activesys.get_system_name()) + '\n'
    except NameError:
        sysname = '\n'
    syst = ' :: ' + yellow_bold('System loaded: ')
    conf = ' :: ' + yellow_bold('Config file: ')
    if saved == NOFILE:
        filename = '\n'
    elif saved == SAVED:
        filename = conffile + '\n'
    elif saved == NOTSAVED:
        filename = bold(conffile + '*\n')
    return conf + filename + syst + sysname
        
    
def prompt(pr):
    return str(raw_input('\n' + pr + ' :: ' + bold('>') + ' '))

def clscr():
    call(['/usr/bin/clear'])

def menu(title,commandlist,quitable=1,backable=0,clean=0):
    command = {}
    arguments = {}
    menu = head(title)
    for quadruple in commandlist:
        act,expl,func,args = quadruple
        menu = menu + ' :: ' + green_bold(act + ') ' + expl) + '\n'
        command[act] = func
        arguments[act] = args
    if quitable:
        menu = menu + ' :: ' + blue_bold('q) quit') + '\n'
        command['q'] = quit_menu
        arguments['q'] = []
    if backable:
        menu = menu + ' :: ' + blue_bold('b) back') + '\n'
        command['b'] = back_menu
        arguments['b'] = []
    if clean:
        clscr()
    print menu
    while True:
        repl = prompt(red_bold('SM'))
        if repl in command:
            if len(arguments[repl]) == 0:
                return command[repl]()
            else:
                return command[repl](arguments[repl])

def null():
    pass

def act_char(title,commandlist):
    lowerchars = 'acdefghijklmnoprstuvwxyz'
    upperchars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    numbers = '0123456789'
    allchars = lowerchars + upperchars + numbers
    title = title.replace(' ','')
    titler = title.replace('b','')
    titler = titler.replace('q','')
    for c in titler + title.upper() + allchars:
        if c not in commandlist:
            return c
        
def new_comm(title,function,commandlist,arguments=[]):
    return commandlist.append((act_char(title,commandlist),
                               title,
                               function,
                               arguments))

def open_sys():
    global statusmsg,activesys
    title = 'Open System'
    if saved == NOFILE:
        statusmsg = 'Config file not available'
    elif len(sysscfg.get_systems_list()) == 0:
        statusmsg = 'No system available'
    else:
        commandlist = []
        for system in sysscfg.get_systems_list():
            name = system.get_system_name()
            new_comm(name,load_sys,commandlist,[name])
#        comm = menu(title,commandlist,quitable=0,backable=1,clean=1)
        menu(title,commandlist,quitable=0,backable=1,clean=1)
#        if comm == 'b':
#            statusmsg = oldmsg
#        else:
#            activesys = comm
#            statusmsg = activesys.get_system_name() + ' opened'
    return 'b'

def create_sys():
    global statusmsg,saved,sysscfg
    title = 'Create New System'
    oldmsg = statusmsg
    statusmsg = 'Fields with (*) symbol are mandatory'
    create = 0    
    systemname = systemdesc = name = ''
    while True:
        clscr()
        print head(title)
        while name == '':
            name = prompt(blue_bold('Insert system name (*) [') +
                          bold(systemname) + 
                          blue_bold(']') )
            if not name == '':
                systemname = name
            elif not systemname == '':
                name = systemname
        systemdesc = prompt(blue_bold('Insert a system description'))
        rep = prompt(red_bold('About to create a new system (insert' +\
                              ' \'q\' to exit):') +\
                     '\n' +\
                     blue_bold('  Name: ') +\
                     bold(systemname) +\
                     '\n' +\
                     blue_bold('  Description: ') +\
                     bold(systemdesc) +\
                     '\n' +\
                     blue_bold('Is this correct? (y/n/q)')).lower()[0]
        if rep == 'y':
            create = 1
            break
        elif rep == 'q':
            break
        statusmsg = 'Something wrong?'
        name = ''
    if create:
        saved = NOTSAVED
        sys = sysman.system.System(systemname,systemdesc)
        sysscfg.add_system(sys)
        statusmsg = 'System %s created' % systemname
    else:
        statusmsg = oldmsg
    return 'b'
    
def delete_sys():
    global activesys,statusmsg,saved,sysscfg
    title = 'Remove a System'
#    oldmsg = statusmsg
    if saved == NOFILE:
        statusmsg = 'Config file not available'
    else:
        commandlist = []
        for system in sysscfg.get_systems_list():
            name = system.get_system_name()
            new_comm(name,rm_sys,commandlist,[name])
        menu(title,commandlist,quitable=0,backable=1,clean=1)
    return 'b'
    
def save_conf():
    print 'save conf'
    
def quit_menu():
    return 'q'

def back_menu():
    return 'b'

def load_sys(namelist):
    global activesys,statusmsg
    if len(namelist) == 1:
        activesys = sysscfg.get_system(namelist[0])
        statusmsg = 'System %s loaded' % namelist[0]
    return 'b'

def rm_sys(namelist):
    global sysscfg,activesys,saved,statusmsg
    if len(namelist) == 1:
        try:
            if activesys.get_system_name() == namelist[0]:
                del activesys
        except NameError:
            pass 
        sysscfg.remove_system(namelist[0])
        statusmsg = 'System %s removed'
        saved = NOTSAVED
    return 'b'

io()
#pkucraina = cPickle.dumps(ucraina)
#print pkucraina
#info = re.sub('[\n\r]','',connection.query('set_conf:%s\n*DONE\n' % pkucraina))
#print info
#io()
#connection.socket().close()